// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package wire

import (
	"context"
	"github.com/Goboolean/common/pkg/resolver"
	"github.com/Goboolean/fetch-system.IaC/internal/connect"
	"github.com/Goboolean/fetch-system.IaC/internal/dbiniter"
	"github.com/Goboolean/fetch-system.IaC/internal/etcd"
	"github.com/Goboolean/fetch-system.IaC/internal/influxdb"
	"github.com/Goboolean/fetch-system.IaC/internal/kafka"
	"github.com/Goboolean/fetch-system.IaC/internal/kis"
	"github.com/Goboolean/fetch-system.IaC/internal/polygon"
	"github.com/Goboolean/fetch-system.IaC/internal/preparer"
	"github.com/Goboolean/fetch-system.IaC/pkg/db"
	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
	"os"
)

import (
	_ "github.com/Goboolean/common/pkg/env"
)

// Injectors from wire_setup.go:

func InitializeKafkaConfigurator(ctx context.Context) (*kafka.Configurator, func(), error) {
	configMap := ProvideKafkaConfig()
	configurator, cleanup, err := ProvideKafkaConfigurator(ctx, configMap)
	if err != nil {
		return nil, nil, err
	}
	return configurator, func() {
		cleanup()
	}, nil
}

func InitializeKafkaProducer(ctx context.Context) (*kafka.Configurator, func(), error) {
	configMap := ProvideKafkaConfig()
	configurator, cleanup, err := ProvideKafkaProducer(ctx, configMap)
	if err != nil {
		return nil, nil, err
	}
	return configurator, func() {
		cleanup()
	}, nil
}

func InitializeETCDClient(ctx context.Context) (*etcd.Client, func(), error) {
	configMap := ProvideETCDConfig()
	client, cleanup, err := ProvideETCDClient(ctx, configMap)
	if err != nil {
		return nil, nil, err
	}
	return client, func() {
		cleanup()
	}, nil
}

func InitializePostgreSQLClient(ctx context.Context) (*db.Queries, func(), error) {
	configMap := ProvidePostgreSQLConfig()
	queries, cleanup, err := ProvidePostgreSQLClient(ctx, configMap)
	if err != nil {
		return nil, nil, err
	}
	return queries, func() {
		cleanup()
	}, nil
}

func InitializeKafkaConnectClient(ctx context.Context) (*connect.Client, func(), error) {
	configMap := ProvideKafkaConnectConfig()
	client, cleanup, err := ProvideKafkaConnectClient(ctx, configMap)
	if err != nil {
		return nil, nil, err
	}
	return client, func() {
		cleanup()
	}, nil
}

func InitializeKISReader() (*kis.Reader, error) {
	configMap := ProvideKISConfig()
	reader, err := ProvideKISReader(configMap)
	if err != nil {
		return nil, err
	}
	return reader, nil
}

func InitializePolygonClient() (*polygon.Client, error) {
	configMap := ProvidePolygonConfig()
	client, err := ProvidePolygonClient(configMap)
	if err != nil {
		return nil, err
	}
	return client, nil
}

func InitializeInfluxDBClient(ctx context.Context) (*influxdb.Client, func(), error) {
	configMap := ProvideInfluxDBConfig()
	client, cleanup, err := ProvideInfluxDBClient(ctx, configMap)
	if err != nil {
		return nil, nil, err
	}
	return client, func() {
		cleanup()
	}, nil
}

func InitializePreparer(ctx context.Context) (*preparer.Manager, func(), error) {
	client, cleanup, err := InitializeETCDClient(ctx)
	if err != nil {
		return nil, nil, err
	}
	queries, cleanup2, err := InitializePostgreSQLClient(ctx)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	configurator, cleanup3, err := InitializeKafkaConfigurator(ctx)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	manager := preparer.New(client, queries, configurator)
	return manager, func() {
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}

func InitializeRetriever(ctx context.Context) (*dbiniter.Manager, func(), error) {
	client, err := InitializePolygonClient()
	if err != nil {
		return nil, nil, err
	}
	queries, cleanup, err := InitializePostgreSQLClient(ctx)
	if err != nil {
		return nil, nil, err
	}
	reader, err := InitializeKISReader()
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	manager := dbiniter.New(client, queries, reader)
	return manager, func() {
		cleanup()
	}, nil
}

// wire_setup.go:

func ProvideKafkaConfig() *resolver.ConfigMap {
	return &resolver.ConfigMap{
		"BOOTSTRAP_HOST": os.Getenv("KAFKA_BOOTSTRAP_HOST"),
	}
}

func ProvideETCDConfig() *resolver.ConfigMap {
	return &resolver.ConfigMap{
		"HOST": os.Getenv("ETCD_HOST"),
	}
}

func ProvidePostgreSQLConfig() *resolver.ConfigMap {
	return &resolver.ConfigMap{
		"HOST":     os.Getenv("POSTGRES_HOST"),
		"PORT":     os.Getenv("POSTGRES_PORT"),
		"USER":     os.Getenv("POSTGRES_USER"),
		"PASSWORD": os.Getenv("POSTGRES_PASSWORD"),
		"DATABASE": os.Getenv("POSTGRES_DATABASE"),
	}
}

func ProvideKafkaConnectConfig() *resolver.ConfigMap {
	return &resolver.ConfigMap{
		"HOST":                   os.Getenv("KAFKA_CONNECT_HOST"),
		"MONGODB_CONNECTION_URI": os.Getenv("MONGODB_CONNECTION_URI"),
		"MONGODB_DATABASE":       os.Getenv("MONGODB_DATABASE"),
	}
}

func ProvideKISConfig() *resolver.ConfigMap {
	return &resolver.ConfigMap{
		"FILEPATH": "./api/csv/data.csv",
	}
}

func ProvidePolygonConfig() *resolver.ConfigMap {
	return &resolver.ConfigMap{
		"SECRET_KEY": os.Getenv("POLYGON_SECRET_KEY"),
	}
}

func ProvideInfluxDBConfig() *resolver.ConfigMap {
	config := &resolver.ConfigMap{
		"URL":    os.Getenv("INFLUXDB_URL"),
		"TOKEN":  os.Getenv("INFLUXDB_TOKEN"),
		"ORG_ID": os.Getenv("INFLUXDB_ORG_ID"),
	}

	return config
}

func ProvideKafkaConfigurator(ctx context.Context, c *resolver.ConfigMap) (*kafka.Configurator, func(), error) {
	k, err := kafka.New(c)
	if err != nil {
		return nil, nil, errors.Wrap(err, "Failed to create kafka configurator")
	}
	if err := k.Ping(ctx); err != nil {
		return nil, nil, errors.Wrap(err, "Failed to send ping to kafka configurator")
	}
	logrus.Info("Kafka configurator is ready")

	return k, func() {
		k.Close()
		logrus.Info("Kafka configurator is successfully closed")
	}, nil
}

func ProvideKafkaProducer(ctx context.Context, c *resolver.ConfigMap) (*kafka.Configurator, func(), error) {
	k, err := kafka.New(c)
	if err != nil {
		return nil, nil, errors.Wrap(err, "Failed to create kafka producer")
	}
	if err := k.Ping(ctx); err != nil {
		return nil, nil, errors.Wrap(err, "Failed to send ping to kafka producer")
	}
	logrus.Info("Kafka producer is ready")

	return k, func() {
		k.Close()
		logrus.Info("Kafka producer is successfully closed")
	}, nil
}

func ProvideETCDClient(ctx context.Context, c *resolver.ConfigMap) (*etcd.Client, func(), error) {
	e, err := etcd.New(c)
	if err != nil {
		return nil, nil, errors.Wrap(err, "Failed to create etcd client")
	}
	logrus.Info("ETCD client is ready")

	return e, func() {
		if err := e.Close(); err != nil {
			logrus.Error(errors.Wrap(err, "Failed to close etcd client"))
		} else {
			logrus.Info("ETCD client is successfully closed")
		}
	}, nil
}

func ProvidePostgreSQLClient(ctx context.Context, c *resolver.ConfigMap) (*db.Client, func(), error) {
	p, err := db.NewDB(c)
	if err != nil {
		return nil, nil, errors.Wrap(err, "Failed to create postgresql client")
	}
	if err := p.Ping(ctx); err != nil {
		return nil, nil, errors.Wrap(err, "Failed to send ping to postgresql client")
	}
	logrus.Info("PostgreSQL client is ready")

	return p, func() {
		p.Close()
		logrus.Info("PostgreSQL client is successfully closed")
	}, nil
}

func ProvideKafkaConnectClient(ctx context.Context, c *resolver.ConfigMap) (*connect.Client, func(), error) {
	k, err := connect.New(c)
	if err != nil {
		return nil, nil, errors.Wrap(err, "Failed to create kafka connect client")
	}
	if err := k.Ping(ctx); err != nil {
		return nil, nil, errors.Wrap(err, "Failed to send ping to kafka connect client")
	}
	logrus.Info("Kafka connect client is ready")

	return k, func() {
		k.Close()
		logrus.Info("Kafka connect client is successfully closed")
	}, nil
}

func ProvideInfluxDBClient(ctx context.Context, c *resolver.ConfigMap) (*influxdb.Client, func(), error) {
	i, err := influxdb.New(c)
	if err != nil {
		return nil, nil, errors.Wrap(err, "Failed to create influxdb client")
	}
	if err := i.Ping(ctx); err != nil {
		return nil, nil, errors.Wrap(err, "Failed to send ping to influxdb client")
	}
	logrus.Info("InfluxDB client is ready")

	return i, func() {
		i.Close()
		logrus.Info("InfluxDB client is successfully closed")
	}, nil
}

func ProvideKISReader(c *resolver.ConfigMap) (*kis.Reader, error) {
	return kis.New(c)
}

func ProvidePolygonClient(c *resolver.ConfigMap) (*polygon.Client, error) {
	return polygon.New(c)
}
